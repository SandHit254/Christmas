<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手势交互粒子圣诞树</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        /* 隐藏视频元素，我们只需要它的数据 */
        .input_video {
            display: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: sans-serif;
            font-size: 24px;
            z-index: 10;
            pointer-events: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loading">正在加载摄像头和模型...</div>
<div id="canvas-container"></div>
<video class="input_video"></video>

<script>
    // ================= MAIN CONFIG =================
    const PARTICLE_COUNT = 4000; // 粒子数量
    const TREE_HEIGHT = 60;
    const TREE_BASE_RADIUS = 25;
    let handPosition = new THREE.Vector3(9999, 9999, 9999); // 初始手部位置在很远的地方
    let isHandDetected = false;

    // Three.js Global Variables
    let scene, camera, renderer, particleSystem;
    let clock = new THREE.Clock();

    // ================= INIT THREE.JS =================
    function initThree() {
        scene = new THREE.Scene();
        // 添加一点迷雾以增加深度感
        scene.fog = new THREE.FogExp2(0x000000, 0.008);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 80;
        camera.position.y = 20;
        camera.lookAt(0, TREE_HEIGHT/2, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        createParticleTree();

        window.addEventListener('resize', onWindowResize);
    }

    // ================= CREATE PARTICLE TREE =================
    function createParticleTree() {
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const initialPositions = []; // 用于存储粒子“家”的位置

        const colorPalette = [
            new THREE.Color(0xff0000), // 红
            new THREE.Color(0x00ff00), // 绿
            new THREE.Color(0xffd700), // 金
            new THREE.Color(0xffffff)  // 白
        ];

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // 使用螺旋形状来构建树
            const angle = Math.random() * Math.PI * 2 * (TREE_HEIGHT / 2); // 螺旋圈数
            const heightRatio = Math.random(); // 0 到 1 的高度比例
            const y = heightRatio * TREE_HEIGHT;
            
            // 半径随着高度增加而减小，形成锥体
            const currentRadius = TREE_BASE_RADIUS * (1 - heightRatio) + Math.random() * 2; // 添加一点随机抖动
            
            const x = Math.cos(angle + y * 0.1) * currentRadius;
            const z = Math.sin(angle + y * 0.1) * currentRadius;

            positions.push(x, y, z);
            initialPositions.push(x, y, z); // 存储原始位置

            // 随机颜色
            const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            colors.push(color.r, color.g, color.b);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        // 将初始位置存储在 geometry 的自定义属性中
        geometry.userData.initialPositions = new THREE.Float32BufferAttribute(initialPositions, 3);

        // 创建一个简单的圆形纹理用于粒子
        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

        const material = new THREE.PointsMaterial({
            size: 1.2,
            vertexColors: true,
            map: sprite,
            blending: THREE.AdditiveBlending, // 发光效果
            transparent: true,
            depthTest: false // 解决粒子相互遮挡的问题
        });

        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
    }


    // ================= MEDIA PIPE HANDS SETUP =================
    const videoElement = document.getElementsByClassName('input_video')[0];

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            isHandDetected = true;
            // 获取第一只手的关键点
            const landmarks = results.multiHandLandmarks[0];
            
            // 我们使用手掌中心 (关键点 9) 或食指指尖 (关键点 8) 作为交互点
            // MediaPipe 的坐标是归一化的 [0.0, 1.0]
            const handXNorm = landmarks[9].x;
            const handYNorm = landmarks[9].y;

            // 将归一化的 2D 坐标映射到 3D 世界坐标
            // 我们需要反转 X 轴，因为摄像头是镜像的
            // Y 轴也要反转，因为 canvas Y 向下，而世界坐标 Y 向上
            const vector = new THREE.Vector3(
                (1 - handXNorm) * 2 - 1,
                -(handYNorm * 2 - 1),
                0.5 // 深度假设
            );

            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z; // 投射到 Z=0 平面附近
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            // 设置交互点的位置，稍微抬高一点 Z 轴让它在树的前面
            handPosition.set(pos.x, pos.y + TREE_HEIGHT/3, 20); 

        } else {
            isHandDetected = false;
            // 手消失时，把交互点移走
            handPosition.set(9999, 9999, 9999);
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const cameraPipe = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    cameraPipe.start();


    // ================= ANIMATION LOOP =================
    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        const positions = particleSystem.geometry.attributes.position.array;
        const initialPositions = particleSystem.geometry.userData.initialPositions.array;

        // 让整棵树缓慢自动旋转
        particleSystem.rotation.y += 0.002;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            const px = positions[i3];
            const py = positions[i3 + 1];
            const pz = positions[i3 + 2];

            const ix = initialPositions[i3];
            const iy = initialPositions[i3 + 1];
            const iz = initialPositions[i3 + 2];
            
            // 计算粒子当前位置
            const currentPos = new THREE.Vector3(px, py, pz);
            const initialPos = new THREE.Vector3(ix, iy, iz);

            // --- 力的计算 ---

            // 1. 回归力 (Spring force back to home)
            // 粒子总是想回到它原始的位置
            const homeForce = initialPos.clone().sub(currentPos).multiplyScalar(0.05);

            // 2. 手势交互力 (Interaction force)
            let interactionForce = new THREE.Vector3(0,0,0);
            
            // 计算粒子到手的距离（需要考虑树的旋转）
            // 将手的位置逆向旋转到粒子的局部空间
            let relativeHandPos = handPosition.clone();
            relativeHandPos.applyAxisAngle(new THREE.Vector3(0,1,0), -particleSystem.rotation.y);

            const distToHand = currentPos.distanceTo(relativeHandPos);
            const effectRadius = 35; // 手的影响半径

            if (distToHand < effectRadius) {
                // 如果手靠近了
                const directionToHand = relativeHandPos.clone().sub(currentPos).normalize();
                // 创建一个吸引力，距离越近吸引力越大
                const strength = (1 - distToHand / effectRadius) * 3.0;
                // 这里设置为吸引力，如果你想改成排斥力，去掉下面那行的负号
                interactionForce = directionToHand.multiplyScalar(strength);
                
                // 甚至可以添加一点旋转力
                // const rotateForce = new THREE.Vector3(-directionToHand.z, 0, directionToHand.x).multiplyScalar(strength * 0.5);
                // interactionForce.add(rotateForce);
            }

            // 3. 添加一点自然的噪点波动
            const noiseForce = new THREE.Vector3(
                Math.sin(time * 2 + py * 0.1) * 0.05,
                Math.cos(time * 1.5 + px * 0.1) * 0.05,
                Math.sin(time + pz * 0.1) * 0.05
            );

            // 应用所有力来更新位置
            currentPos.add(homeForce);
            currentPos.add(interactionForce);
            currentPos.add(noiseForce);

            positions[i3] = currentPos.x;
            positions[i3 + 1] = currentPos.y;
            positions[i3 + 2] = currentPos.z;
        }

        // 重要：告诉 Three.js 位置属性已更新
        particleSystem.geometry.attributes.position.needsUpdate = true;

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ================= START =================
    initThree();
    animate();

</script>
</body>
</html>